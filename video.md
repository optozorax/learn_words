# для создания видео

* засечь время написания идей
* засечь время написания плана
* начать планировать структуры данных, записать это время
* начать кодить программу
* на каждый этап делать коммиты
* условие: всё должно быть сделано за 2 рабочих дня, то есть за 16 часов

# информация

* время написания первых идей: 20 минут
* время их ситематизации: 20 минут
* планирование структур данных, связанных с основной логикой, без учёта интерфейса: 1 час 20 минут
* планирование структур и методов интерфейса: 30 минут (2:32)
* написание кода основной логики: 1 час (3:32)
* написание кода интерфейса до минимально рабочего состояния: 2ч 45м (6:16)
* сделал два пункта и распланировал дальнейшие идеи в todo: 45м (7:02)
* слетел таймер
* три общих пункта: 47м (0:47)
* основа статистики: 34м (1:21)
* рефакторинг окон: 30м (1:51)
* реализация статистики и других мелких улучшений: 1ч 53м (3:44)
* раскладка клавиатуры: 1ч 4м (4:48)
* github-like плитка: 3ч (7:44)
* написал quad-storage: 1ч 49м (9:33)
* заставил запускаться в васме, пофиксил баги и небольшие дополнения: 1ч 50м (11:23)
* скинул таймер
* написание статьи про программу: 2ч 56м
* в полной статистике суммировать всё время пользования
* закончил править все критичные пункты: 1ч 30м
* начал таймер
* сделал чтобы можно было выбирать количество слов: 44 минуты (0:44)
* сделал чтобы можно было искать по всем словам с fuzzy поиском и это работало при добавлении слова: 1ч 2м (1:46)
* сделал окно для редактирования одного слова: 53м (2:39)
* добавил показ контекста данного слова из текста: 46м (3:15)
* для работы можно выбирать количество новых слов и количество слов для повторения: 21м (3:36)
* добавил вывод информации о количестве слов в тексте после добавления: 20м (3:56)
* фича синхронных субтитров: 3ч 26м (7:22)
* мелкие фичи: 57м (8:19)
* переход на другой генератор рандома: 10м (8:29)
* сбросил таймер
* дописал статью про программу с учётом новых фич и пользования: 2ч 3м
* повторение слов после неправильного ввода и инвертирование результатов: 1ч 48м
* улучшения окна add words: 20м

# пользование

* 1й день
	* добавление
		* S1E1 агентов щит субтитры
		* 900 слов
		* 50 минут добавлял
		* 70 новых слов
	* изучение
		* 762 попытки
		* 681 правильная
		* 81 неправильная
		* 55 минут писал варианты
* с новой системой
	* 272 попытки на 15 новых слов и 30 для повторения, 18 минут.
* 7 августа
	* 30 новых слов, 30 слов для повторения
	* 331 попытка
	* 20 минут
* мой результат 4920 слов по сайту http://testyourvocab.com/result?user=16791060
* текст https://www.lesswrong.com/posts/o5F2p3krzT4JgzqQc/causal-universes
	* 3573 слов
	* 960 уникальных
	* 464 отфильтровано
	* 496 неизвестных
	* 53 слова реально не знаю

# идеи

* Чтобы код был проще, надо не только заранее продумать структуры данных, а ещё и создать такие структуры данных, которые позволят решать задачу намного проще, без копипасты кода и лишних вычислений. Например, такой структурой является `WordsOptimized`, потому что там заранее вычислится массив `to_type_today`.
* Этот способ планирования программы не идеал, вам следует это адаптировать под себя.
* Я занимаюсь таким планированием не только при написании новой программы, но и когда нужно отрефакторить или сделать новую фичу.
* Чтобы набрасывать функции и структуры данных я очень много сижу над идеями, перечитываю их и пытаюсь понять как они должны выглядеть в коде.
* Сначала надо делать как можно меньше фич, а затем добавлять новые фичи только если они прям горят
* Посмотрите на весь этот процесс, вы считаете что такое серьёзно можно заменить какой-то там нейросетью? Нет, только Сильный ИИ способен на такое.
* То что задача наполовину решена - это когда я распланировал структуру LearnWords. Я её почему-то сразу не спланировал, но зато когда придумал, то двигаться дальше стало намного легче.
* Поначалу я вообще не пользовался todo файлом, потому что у меня всё было в коде и в файлике с идеями, а теперь, когда я закончил прогу, теперь все независимые друг от друга идеи можно превратить в фичи и туду-листы.
* Статья преследует две цели: показать как я делаю программы и показать насколько просто создавать интерфейсы с imgui.
* Структура данных в данной статье имеется ввиду не деревья, односвязные списки итд, а просто enum и struct, которыми описывается структура входных данных.
* Не понимаю как можно работать на динамически типизированных языках, если на них нельзя написать эти структуры, ибо я уже в такой простой программе путаюсь без структур. Может у них мозг по-другому работает.
* imgui отлично подходит для кейка когда надо написать прогу, которой будут пользоваться только внутри компании, и для неё не надо прикладывать слишком много усилий.
* Так быстро было сделано не только благодаря планированию и imgui, а ещё потому что я ещё на этапе идей откинул очень времязатратные вещи типо нормализации слов или встроенного словаря. Такие вещи надо заранее откидывать, иначе ты никогда не сделаешь программу. Вначале всё должно быть тупо и вручную. А затем уже можно в качестве фичи подумать насчёт таких супер-сложных фич. Исключения составляют программы, где самой основой является супер-сложная фича.
* Прямо во время пользования нахожу неудобства и записываю их в туду.
* Я доказал себе что могу создать прогу с таким сложным интерфейсом так быстро.
* Я использую туду для всех своих проектов и у меня для каждого проекта есть свой todo файл.
* Идеи для программы приходят в самых неожиданных местах, поэтому надо их все записывать, а затем заносить либо в туду, либо в файл с идеями. Иногда можно перечитывать файл с идеями, чтобы они были свежими в голове, и чтобы при пользовании можно было увидеть как конкретно эту идею можно реализовать и чем она может быть полезна.
* Когда тудушка переполняется, я создаю раздел архив, куда помещаю все отменённые и выполненные задачи. не знаю зачем я всё сохраняю, наверное чтобы видеть как много работы было проделано над конкретным проектом.
* Для всех этих тудушек и идей очень удобно владеть быстрой слепой печатью.
* Я делал сбор идей ещё в 10 классе, когда делал древовидную структуру в html, где ветки выделял разными цветами. Кстати, это можно использовать вместо md, в обычном файлике через символ tab.
* Тудушки должны напрямую влиять на текущий проект, а идеи просто записываться в отдельный файл, чтобы в отдельный день выстрелить.
* Чтобы забайтить на чтение статьи про программу можно сказать что она самая лучшая.
* Изначально я планировал не учитывать многозначность во имя простоты, но понял что без этого программа будет просто неюзабельна. Поэтому пришлось это хорошо продумать.
* при планировании новой фичи важно не только продумать её, но и ещё постараться сделать это так, чтобы она вносилась минимальными усилиями, чтобы не пришлось половину программы рефакторить из-за неё
* imgui можно использовать для прототипирования, а затем уже когда весь интерфейс отладится, делать его уже на качественном коллбэчном интерфейсе.
* Я даже подумать не мог до создания программы что может понадобиться возможность выбирать количество слов, вот почему крайне важно иметь возможность очень быстро отредактировать код. imgui это позволяет сделать. https://t.me/optozorax_dev_chat/5158
* В реальности невозможно работать так эффективно как я при замере времени, потому что это выматывает. И на самом деле в день, если я работаю с утра до вечера, набирается 6 часов чистого времени. Проверить это по таймингам. А если и стараться все 8 рабочих часов делать чистое время, то психическое здоровье очень быстро умрёт.
* Превью для статьи о том как я пишу программы: наполовину туду выполненная наполовину, четверть идеи, четверть интерфейс.
* Отдельно секция про планирование, отдельно про imgui.
* Для меня imgui примерно такое же откровение, как и емуны в расте.
* Ещё крайне удобно собирать идеи для статьи во время написания проги, как я делаю в этот момент.
* До начала написания программы первым делом я собираю все хотелки в файле "идеи".
* Я пишу в одном файле, потому что пока не вижу потребности в разделении. И это норм. Тем более после всего написанного кода видна какая-то более-менее адекватная файловая структура, которую можно раскидать. То если систематизировать что-то надо только тогда, когда есть достаточно элементов этой категории. Если элементов всего 1, то может случиться так, что 1 и останется и ты зря создал какую-то категорию (пространство имён, папку).
* Иногда сталкиваешься с потребностью написать сложный алгоритм, как у меня было с расстановкой синхронных сабов. В таких случаях очень кстати иметь опыт олимпиадного программирования, чтобы суметь в короткий срок найти нужное решение, и рассмотреть все предельные случаи и гарантии. У меня не было гарантий что сабы идут последовательно, и я предположил худший вариант, но смог для него сделать довольно простой алгоритм. В этом есть полезность задалбливания олимпиадок. И такое простые нейросетки не заменят. Это полноценный процесс размышления, который может решить только сильный ИИ.
* написать отдельно статью про имгуи, про любовь к нему, что я да и все начинали с консольных приложух, а вот с имгуи можно прям развернуться.
