# для создания видео

* засечь время написания идей
* засечь время написания плана
* начать планировать структуры данных, записать это время
* начать кодить программу
* на каждый этап делать коммиты
* условие: всё должно быть сделано за 2 рабочих дня, то есть за 16 часов

# информация

* время написания первых идей: 20 минут
* время их ситематизации: 20 минут
* планирование структур данных, связанных с основной логикой, без учёта интерфейса: 1 час 20 минут
* планирование структур и методов интерфейса: 30 минут (2:32)
* написание кода основной логики: 1 час (3:32)
* написание кода интерфейса до минимально рабочего состояния: 2ч 45м (6:16)
* сделал два пункта и распланировал дальнейшие идеи в todo: 45м (7:02)
* слетел таймер
* три общих пункта: 47м (0:47)
* основа статистики: 34м (1:21)
* рефакторинг окон: 30м (1:51)
* реализация статистики и других мелких улучшений: 1ч 53м (3:44)
* раскладка клавиатуры: 1ч 4м (4:48)
* github-like плитка: 3ч (7:44)
* написал quad-storage: 1ч 49м (9:33)
* заставил запускаться в васме, пофиксил баги и небольшие дополнения: 1ч 50м (11:23)
* скинул таймер
* написание статьи про программу: 2ч 56м
* в полной статистике суммировать всё время пользования
* закончил править все критичные пункты: 1ч 30м
* начал таймер
* сделал чтобы можно было выбирать количество слов: 44 минуты (0:44)
* сделал чтобы можно было искать по всем словам с fuzzy поиском и это работало при добавлении слова: 1ч 2м (1:46)

# пользование

* 1й день
	* добавление
		* S1E1 агентов щит субтитры
		* 900 слов
		* 50 минут добавлял
		* 70 новых слов
	* изучение
		* 762 попытки
		* 681 правильная
		* 81 неправильная
		* 55 минут писал варианты

# идеи

* Чтобы код был проще, надо не только заранее продумать структуры данных, а ещё и создать такие структуры данных, которые позволят решать задачу намного проще, без копипасты кода и лишних вычислений. Например, такой структурой является `WordsOptimized`, потому что там заранее вычислится массив `to_type_today`.
* Этот способ планирования программы не идеал, вам следует это адаптировать под себя.
* Я занимаюсь таким планированием не только при написании новой программы, но и когда нужно отрефакторить или сделать новую фичу.
* Чтобы набрасывать функции и структуры данных я очень много сижу над идеями, перечитываю их и пытаюсь понять как они должны выглядеть в коде.
* Сначала надо делать как можно меньше фич, а затем добавлять новые фичи только если они прям горят
* Посмотрите на весь этот процесс, вы считаете что такое серьёзно можно заменить какой-то там нейросетью? Нет, только Сильный ИИ способен на такое.
* То что задача наполовину решена - это когда я распланировал структуру LearnWords. Я её почему-то сразу не спланировал, но зато когда придумал, то двигаться дальше стало намного легче.
* Поначалу я вообще не пользовался todo файлом, потому что у меня всё было в коде и в файлике с идеями, а теперь, когда я закончил прогу, теперь все независимые друг от друга идеи можно превратить в фичи и туду-листы.
* Статья преследует две цели: показать как я делаю программы и показать насколько просто создавать интерфейсы с imgui.
* Структура данных в данной статье имеется ввиду не деревья, односвязные списки итд, а просто enum и struct, которыми описывается структура входных данных.
* Не понимаю как можно работать на динамически типизированных языках, если на них нельзя написать эти структуры, ибо я уже в такой простой программе путаюсь без структур. Может у них мозг по-другому работает.
* imgui отлично подходит для кейка когда надо написать прогу, которой будут пользоваться только внутри компании, и для неё не надо прикладывать слишком много усилий.
* Панелька снизу со статистикой вдохновлена verseq
* Так быстро было сделано не только благодаря планированию и imgui, а ещё потому что я ещё на этапе идей откинул очень времязатратные вещи типо нормализации слов или встроенного словаря. Такие вещи надо заранее откидывать, иначе ты никогда не сделаешь программу. Вначале всё должно быть тупо и вручную. А затем уже можно в качестве фичи подумать насчёт таких супер-сложных фич. Исключения составляют программы, где самой основой является супер-сложная фича.
* Прямо во время пользования нахожу неудобства и записываю их в туду.
* Я доказал себе что могу создать прогу с таким сложным интерфейсом так быстро.
* Я использую туду для всех своих проектов и у меня для каждого проекта есть свой todo файл.
* Идеи для программы приходят в самых неожиданных местах, поэтому надо их все записывать, а затем заносить либо в туду, либо в файл с идеями. Иногда можно перечитывать файл с идеями, чтобы они были свежими в голове, и чтобы при пользовании можно было увидеть как конкретно эту идею можно реализовать и чем она может быть полезна.
* Когда тудушка переполняется, я создаю раздел архив, куда помещаю все отменённые и выполненные задачи. не знаю зачем я всё сохраняю, наверное чтобы видеть как много работы было проделано над конкретным проектом.
* Для всех этих тудушек и идей очень удобно владеть быстрой слепой печатью.
* Я делал сбор идей ещё в 10 классе, когда делал древовидную структуру в html, где ветки выделял разными цветами. Кстати, это можно использовать вместо md, в обычном файлике через символ tab.
* Тудушки должны напрямую влиять на текущий проект, а идеи просто записываться в отдельный файл, чтобы в отдельный день выстрелить.
* Чтобы забайтить на чтение статьи про программу можно сказать что она самая лучшая.
* Изначально я планировал не учитывать многозначность во имя простоты, но понял что без этого программа будет просто неюзабельна. Поэтому пришлось это хорошо продумать.
* Иметь одновременно рус-англ и англ-рус важно, потому что когда видишь английское слово, вспомнить русское может быть легко, а наоборот нет.